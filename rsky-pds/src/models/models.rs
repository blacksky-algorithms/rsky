// Generated by diesel_ext

#![allow(unused)]
#![allow(clippy::all)]

use anyhow::{bail, Result};
use chrono::offset::Utc;
use chrono::DateTime;
use diesel::backend::Backend;
use diesel::deserialize::FromSql;
use diesel::prelude::*;
use diesel::serialize::{Output, ToSql};
use diesel::sql_types::Text;
use diesel::*;

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(primary_key(did))]
#[diesel(table_name = crate::schema::pds::account)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct Account {
    pub did: String,
    pub email: String,
    #[diesel(column_name = recoveryKey)]
    #[serde(rename = "recoveryKey")]
    pub recovery_key: Option<String>,
    pub password: String,
    #[diesel(column_name = createdAt)]
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[diesel(column_name = invitesDisabled)]
    #[serde(rename = "invitesDisabled")]
    pub invites_disabled: i16,
    #[diesel(column_name = emailConfirmedAt)]
    #[serde(rename = "emailConfirmedAt")]
    pub email_confirmed_at: Option<String>,
}

#[derive(
    Queryable,
    Identifiable,
    Insertable,
    Selectable,
    Clone,
    Debug,
    PartialEq,
    Default,
    Serialize,
    Deserialize,
)]
#[diesel(table_name = crate::schema::pds::account_pref)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct AccountPref {
    pub id: i32,
    pub name: String,
    #[diesel(column_name = valueJson)]
    #[serde(rename = "valueJson")]
    pub value_json: Option<String>,
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(primary_key(did))]
#[diesel(table_name = crate::schema::pds::actor)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct Actor {
    pub did: String,
    pub handle: Option<String>,
    #[diesel(column_name = createdAt)]
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[diesel(column_name = takedownRef)]
    #[serde(rename = "takedownRef")]
    pub takedown_ref: Option<String>,
    #[diesel(column_name = deactivatedAt)]
    #[serde(rename = "deactivatedAt")]
    pub deactivated_at: Option<String>,
    #[diesel(column_name = deleteAfter)]
    #[serde(rename = "deleteAfter")]
    pub delete_after: Option<String>,
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(primary_key(did, name))]
#[diesel(table_name = crate::schema::pds::app_password)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct AppPassword {
    pub did: String,
    pub name: String,
    pub password: String,
    #[diesel(column_name = createdAt)]
    #[serde(rename = "createdAt")]
    pub created_at: String,
}

#[derive(
    Queryable,
    Identifiable,
    Insertable,
    Selectable,
    Clone,
    Debug,
    PartialEq,
    Default,
    Serialize,
    Deserialize,
)]
#[diesel(primary_key(uri, path))]
#[diesel(table_name = crate::schema::pds::backlink)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct Backlink {
    pub uri: String,
    pub path: String,
    #[diesel(column_name = linkTo)]
    #[serde(rename = "linkTo")]
    pub link_to: String,
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(treat_none_as_null = true)]
#[diesel(primary_key(cid))]
#[diesel(table_name = crate::schema::pds::blob)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct Blob {
    pub cid: String,
    pub did: String,
    #[diesel(column_name = mimeType)]
    #[serde(rename = "mimeType")]
    pub mime_type: String,
    pub size: i32,
    #[diesel(column_name = tempKey)]
    #[serde(rename = "tempKey")]
    pub temp_key: Option<String>,
    pub width: Option<i32>,
    pub height: Option<i32>,
    #[diesel(column_name = createdAt)]
    #[serde(rename = "createdAt")]
    pub created_at: String,
    #[diesel(column_name = takedownRef)]
    #[serde(rename = "takedownRef")]
    pub takedown_ref: Option<String>,
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(primary_key(did))]
#[diesel(table_name = crate::schema::pds::did_doc)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct DidDoc {
    pub did: String,
    pub doc: String,
    #[diesel(column_name = updatedAt)]
    #[serde(rename = "updatedAt")]
    pub updated_at: i64,
}

#[derive(
    Clone, Copy, Debug, PartialEq, Eq, Hash, Default, Serialize, Deserialize, AsExpression,
)]
#[diesel(sql_type = Text)]
pub enum EmailTokenPurpose {
    #[default]
    ConfirmEmail,
    UpdateEmail,
    ResetPassword,
    DeleteAccount,
    PlcOperation,
}

impl EmailTokenPurpose {
    pub fn as_str(&self) -> &'static str {
        match self {
            EmailTokenPurpose::ConfirmEmail => "confirm_email",
            EmailTokenPurpose::UpdateEmail => "update_email",
            EmailTokenPurpose::ResetPassword => "reset_password",
            EmailTokenPurpose::DeleteAccount => "delete_account",
            EmailTokenPurpose::PlcOperation => "plc_operation",
        }
    }

    pub fn from_str(s: &str) -> Result<Self> {
        match s {
            "confirm_email" => Ok(EmailTokenPurpose::ConfirmEmail),
            "update_email" => Ok(EmailTokenPurpose::UpdateEmail),
            "reset_password" => Ok(EmailTokenPurpose::ResetPassword),
            "delete_account" => Ok(EmailTokenPurpose::DeleteAccount),
            "plc_operation" => Ok(EmailTokenPurpose::PlcOperation),
            _ => bail!("Unable to parse as EmailTokenPurpose: `{s:?}`"),
        }
    }
}

impl<DB> Queryable<Text, DB> for EmailTokenPurpose
where
    DB: Backend,
    String: FromSql<Text, DB>,
{
    type Row = String;

    fn build(s: String) -> deserialize::Result<Self> {
        Ok(EmailTokenPurpose::from_str(&s)?)
    }
}

impl ToSql<Text, pg::Pg> for EmailTokenPurpose
where
    String: ToSql<Text, pg::Pg>,
{
    fn to_sql<'b>(&'b self, out: &mut Output<'b, '_, pg::Pg>) -> serialize::Result {
        let v = self.as_str().to_owned();
        <String as ToSql<Text, pg::Pg>>::to_sql(&v, &mut out.reborrow())
    }
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(primary_key(purpose, did))]
#[diesel(table_name = crate::schema::pds::email_token)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct EmailToken {
    pub purpose: EmailTokenPurpose,
    pub did: String,
    pub token: String,
    #[diesel(column_name = requestedAt)]
    #[serde(rename = "requestedAt")]
    pub requested_at: String,
}

#[derive(
    Queryable,
    Identifiable,
    Insertable,
    Selectable,
    Clone,
    Debug,
    PartialEq,
    Default,
    Serialize,
    Deserialize,
)]
#[diesel(primary_key(code))]
#[diesel(table_name = crate::schema::pds::invite_code)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct InviteCode {
    pub code: String,
    #[diesel(column_name = availableUses)]
    #[serde(rename = "availableUses")]
    pub available_uses: i32,
    pub disabled: i16,
    #[diesel(column_name = forAccount)]
    #[serde(rename = "forAccount")]
    pub for_account: String,
    #[diesel(column_name = createdBy)]
    #[serde(rename = "createdBy")]
    pub created_by: String,
    #[diesel(column_name = createdAt)]
    #[serde(rename = "createdAt")]
    pub created_at: String,
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(primary_key(code, usedBy))]
#[diesel(table_name = crate::schema::pds::invite_code_use)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct InviteCodeUse {
    pub code: String,
    #[diesel(column_name = usedBy)]
    #[serde(rename = "usedBy")]
    pub used_by: String,
    #[diesel(column_name = usedAt)]
    #[serde(rename = "usedAt")]
    pub used_at: String,
}

#[derive(
    Queryable,
    Identifiable,
    Insertable,
    Selectable,
    Clone,
    Debug,
    PartialEq,
    Default,
    Serialize,
    Deserialize,
)]
#[diesel(primary_key(uri))]
#[diesel(table_name = crate::schema::pds::record)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct Record {
    pub uri: String,
    pub cid: String,
    pub did: String,
    pub collection: String,
    pub rkey: String,
    #[diesel(column_name = repoRev)]
    #[serde(rename = "repoRev")]
    pub repo_rev: Option<String>,
    #[diesel(column_name = indexedAt)]
    #[serde(rename = "indexedAt")]
    pub indexed_at: String,
    #[diesel(column_name = takedownRef)]
    #[serde(rename = "takedownRef")]
    pub takedown_ref: Option<String>,
}

#[derive(
    QueryableByName,
    Queryable,
    Identifiable,
    Selectable,
    Clone,
    Debug,
    PartialEq,
    Default,
    Serialize,
    Deserialize,
)]
#[diesel(primary_key(blobCid, recordUri))]
#[diesel(table_name = crate::schema::pds::record_blob)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct RecordBlob {
    #[diesel(column_name = blobCid, sql_type = Text)]
    #[serde(rename = "blobCid")]
    pub blob_cid: String,
    #[diesel(column_name = recordUri, sql_type = Text)]
    #[serde(rename = "recordUri")]
    pub record_uri: String,
    #[diesel(sql_type = Text)]
    pub did: String,
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(table_name = crate::schema::pds::refresh_token)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct RefreshToken {
    pub id: String,
    pub did: String,
    #[diesel(column_name = expiresAt)]
    #[serde(rename = "expiresAt")]
    pub expires_at: String,
    #[diesel(column_name = nextId)]
    #[serde(rename = "nextId")]
    pub next_id: Option<String>,
    #[diesel(column_name = appPasswordName)]
    #[serde(rename = "appPasswordName")]
    pub app_password_name: Option<String>,
}

#[derive(
    Queryable,
    Identifiable,
    Selectable,
    Insertable,
    Clone,
    Debug,
    PartialEq,
    Default,
    Serialize,
    Deserialize,
)]
#[diesel(primary_key(cid))]
#[diesel(table_name = crate::schema::pds::repo_block)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct RepoBlock {
    #[diesel(sql_type = Text)]
    pub cid: String,
    pub did: String,
    #[diesel(column_name = repoRev)]
    #[serde(rename = "repoRev")]
    pub repo_rev: String,
    pub size: i32,
    #[diesel(sql_type = Bytea)]
    pub content: Vec<u8>,
}

#[derive(
    Queryable, Identifiable, Selectable, Clone, Debug, PartialEq, Default, Serialize, Deserialize,
)]
#[diesel(primary_key(did))]
#[diesel(table_name = crate::schema::pds::repo_root)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct RepoRoot {
    pub did: String,
    pub cid: String,
    pub rev: String,
    #[diesel(column_name = indexedAt)]
    #[serde(rename = "indexedAt")]
    pub indexed_at: String,
}

#[derive(
    Queryable,
    Identifiable,
    Selectable,
    Insertable,
    Clone,
    Debug,
    PartialEq,
    Default,
    Serialize,
    Deserialize,
)]
#[diesel(primary_key(seq))]
#[diesel(table_name = crate::schema::pds::repo_seq)]
#[diesel(check_for_backend(diesel::pg::Pg))]
pub struct RepoSeq {
    #[diesel(deserialize_as = i64)]
    pub seq: Option<i64>,
    pub did: String,
    #[diesel(column_name = eventType)]
    #[serde(rename = "eventType")]
    pub event_type: String,
    pub event: Vec<u8>,
    #[diesel(deserialize_as = i16)]
    pub invalidated: Option<i16>,
    #[diesel(column_name = sequencedAt)]
    #[serde(rename = "sequencedAt")]
    pub sequenced_at: String,
}

impl RepoSeq {
    pub fn new(did: String, event_type: String, event: Vec<u8>, sequenced_at: String) -> Self {
        RepoSeq {
            did,
            event_type,
            event,
            sequenced_at,
            invalidated: None, // default values used on insert
            seq: None,         // default values used on insert
        }
    }
}
